:mod:`pyfk.gf.gf`
=================

.. py:module:: pyfk.gf.gf


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   pyfk.gf.gf.calculate_gf
   pyfk.gf.gf.calculate_gf_source
   pyfk.gf.gf.waveform_integration


.. function:: calculate_gf(config: Optional[Config] = None) -> Union[(List[Stream], List[Stream])]

   Compute displacements in cm in the up, radial (outward), and transverse (clockwise) directions produced by different seismic sources

   :param config: the configuration of calculating the Green's function, defaults to None
   :type config: Optional[Config], optional
   :return: if npt==2 or 1, return a 2D list, and each row represents the static displacements; otherwise, return a list of Stream, each stream keeps the order of GF as in FK, and the order of streams is the same as the receiver_distance.
   :rtype: Union[List[Stream], List[Stream]]


.. function:: calculate_gf_source(src_type: str, model: pyfk.config.config.SeisModel, flip: bool, src_layer: int) -> numpy.ndarray

   calculate the source matrix used in propogational matrix operations

   :param src_type: the type of the source
   :type src_type: str
   :param model: the Earth model
   :type model: SeisModel
   :param flip: if the source and the receiver should be fliped
   :type flip: bool
   :param src_layer: the layer where the source is located
   :type src_layer: int
   :return: the source matrix
   :rtype: np.ndarray


.. function:: waveform_integration(model: pyfk.config.config.SeisModel, config: pyfk.config.config.Config, src_layer: int, rcv_layer: int, taper: float, pmin: float, pmax: float, dk: float, nfft2: int, dw: float, kc: float, flip: bool, filter_const: float, dynamic: bool, wc1: int, wc2: int, t0: numpy.ndarray, wc: int, si: numpy.ndarray, sigma: float) -> numpy.ndarray

   the main function wrapping the cython module, do the wave number integration.

   :param model: the Earth model
   :type model: SeisModel
   :param config: the configuration of calculating GF
   :type config: Config
   :param src_layer: the layer where the source is located (source at the bottom)
   :type src_layer: int
   :param rcv_layer: the layer where the receiver is located (receiver at the top)
   :type rcv_layer: int
   :param taper: the taper value
   :type taper: float
   :param pmin: the min slowness
   :type pmin: float
   :param pmax: the max slowness
   :type pmax: float
   :param dk: sampling interval of wavenumber
   :type dk: float
   :param nfft2: the half of simulation points
   :type nfft2: int
   :param dw: sampling interval of frequency
   :type dw: float
   :param kc: the max wave number
   :type kc: float
   :param flip: if the source and the receiver has been fliped
   :type flip: bool
   :param filter_const: the const value used in filtering
   :type filter_const: float
   :param dynamic: if performing the dynamic simulation
   :type dynamic: bool
   :param wc1: the starting point of wave number integration
   :type wc1: int
   :param wc2: the end point beyond which the filtering will take effect
   :type wc2: int
   :param t0: the first arrival time
   :type t0: np.ndarray
   :param wc: the end point beyond which the taper will take effect
   :type wc: int
   :param si: the source matrix
   :type si: np.ndarray
   :param sigma: the value to supress the numerical noise
   :type sigma: float
   :return: the result of doing wavenumber integration
   :rtype: np.ndarray


