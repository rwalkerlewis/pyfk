:py:mod:`pyfk`
==============

.. py:module:: pyfk


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   config/index.rst
   gf/index.rst
   sync/index.rst
   taup/index.rst
   tests/index.rst
   utils/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   setting/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   pyfk.Config
   pyfk.SeisModel
   pyfk.SourceModel



Functions
~~~~~~~~~

.. autoapisummary::

   pyfk.calculate_gf
   pyfk.calculate_sync
   pyfk.generate_source_time_function



.. py:class:: Config(model = None, source = None, receiver_distance = None, planet_radius = 6371.0, degrees = False, taper = 0.3, filter = (0, 0), npt = 256, dt = 1.0, dk = 0.3, smth = 1.0, pmin = 0.0, pmax = 1.0, kmax = 15.0, rdep = 0.0, updn = 'all', samples_before_first_arrival = 50, suppression_sigma = 2.0, cuda = False)

   Bases: :py:obj:`object`

   The configuration class used in generating Green's function and the synthetic waveform.

   :param model: the Earth model used in calculation, defaults to None
   :type model: Optional[SeisModel]
   :param source: the source model used in calculation, defaults to None
   :type source: Optional[SourceModel]
   :param receiver_distance: a list of receiver distance in km, defaults to None
   :type receiver_distance: Optional[Union[list, np.ndarray]]
   :param degrees: use degrees instead of km, defaults to False
   :type degrees: bool, optional
   :param planet_radius: the radius of the planet in km, default to 6371.
   :type planet_radius: float, optional
   :param taper: taper applies a low-pass cosine filter at fc=(1-taper)*f_Niquest, defaults to 0.3
   :type taper: float, optional
   :param filter: apply a high-pass filter with a cosine transition zone between freq. f1 and f2 in Hz, defaults to (0, 0)
   :type filter: Tuple[float, float], optional
   :param npt: the number of points, defaults to 256
   :type npt: int, optional
   :param dt: the sampling interval in seconds, defaults to 1.
   :type dt: float, optional
   :param dk: the non-dimensional sampling interval of wavenumber, defaults to 0.3
   :type dk: float, optional
   :param smth: makes the final sampling interval to be dt/smth, defaults to 1.
   :type smth: float, optional
   :param pmin: the min slownesses in term of 1/vs_at_the_source, defaults to 0.
   :type pmin: float, optional
   :param pmax: the max slownesses in term of 1/vs_at_the_source, defaults to 1.
   :type pmax: float, optional
   :param kmax: kmax at zero frequency in term of 1/hs, defaults to 15.
   :type kmax: float, optional
   :param rdep: the depth for the receivers in km, defaults to 0.
   :type rdep: float, optional
   :param updn: "up" for up-going wave only, "down" for down-going wave only, "all" for both "up" and "down", defaults to "all"
   :type updn: str, optional
   :param samples_before_first_arrival: the number of points before the first arrival, defaults to 50
   :type samples_before_first_arrival: int, optional
   :param suppression_sigma: the suppression factor of the numerical noise, defaults to 2
   :type suppression_sigma: float, optional
   :param cuda: whether to use the cuda mode. if set PYFK_USE_CUDA=1, this flag will be ignored and will always use cuda, defaults to False
   :type cuda: bool
   :raises PyfkError: Must provide a list of receiver distance
   :raises PyfkError: Can't set receiver distance as 0, please consider to use a small value instead
   :raises PyfkError: planet_radius should be positive
   :raises PyfkError: Taper must be with (0,1)
   :raises PyfkError: Filter must be a tuple (f1,f2), f1 and f2 should be within [0,1]
   :raises PyfkError: npt should be positive.
   :raises PyfkError: dt should be positive.
   :raises PyfkError: dk should be within (0,0.5)
   :raises PyfkError: smth should be positive.
   :raises PyfkError: pmin should be within [0,1]
   :raises PyfkError: pmax should be within [0,1]
   :raises PyfkError: pmin should be smaller than pmax
   :raises PyfkError: kmax should be larger or equal to 10
   :raises PyfkError: the selection of phases should be either 'up', 'down' or 'all'
   :raises PyfkError: samples_before_first_arrival should be positive
   :raises PyfkError: suppression_sigma should be positive
   :raises PyfkError: Must provide a source
   :raises PyfkError: Must provide a seisModel

   .. py:method:: __repr__()

      Return repr(self).


   .. py:method:: _couple_model_and_source()


   .. py:method:: _flattening_func(depth)


   .. py:method:: _insert_intf(depth)



.. py:class:: SeisModel(model = None, flattening = False, use_kappa = False, r_planet = None)

   Bases: :py:obj:`object`

   SeisModel stores the Earth model

   :param model: numpy.ndarray model: a 2D numpy array storing the information of the 1D earth model, with the same format as FK.
          model has the following format (in units of km, km/s, g/cm3, each column):
          thickness vs vp_or_vp/vs [rho Qs Qp]
          rho=0.77 + 0.32*vp if not provided or the 4th column is larger than 20 (treated as Qs).
          Qs=500, Qp=2*Qs, if they are not specified.
          If the first layer thickness is zero, it represents the top elastic half-space.
          Otherwise, the top half-space is assumed to be vacuum and does not need to be specified.
          The last layer (i.e. the bottom half space) thickness should be always be zero. (if not, will use 0 anyway), defaults to None
   :type model: np.ndarray
   :param flattening: if the model and the source should be flatten, defaults to False
   :type flattening: bool, optional
   :param use_kappa: if the third column of the model file is vp/vs ratio, defaults to False
   :type use_kappa: bool, optional
   :param r_planet: the optional defined planet radius in KM. If not defined, the value will be None and the Earth radius = 6371.0 km will be used
   :type r_planet: float, optional
   :raises PyfkError: Earth Model must be a 2D numpy array
   :raises PyfkError: Must provide at least three columns for the model
   :raises PyfkError: r_planet should be a float or integer number
   :raises PyfkError: r_planet must be a positive value

   .. py:method:: __copy__()

      make a copy of the current model, and the model numpy file will not be influenced

      :return: the copied SeisModel
      :rtype: SeisModel


   .. py:method:: __repr__()

      Return repr(self).


   .. py:method:: add_layer(dd, idep)

      insert a layer so that the source/receiver will be located at the interface of the layers

      :param dd: the distance(km) to the bottom of the later where the source/receiver is located
      :type dd: float
      :param idep: the layer (top most layer as index 0) where the source/receiver is located
      :type idep: int


   .. py:method:: flattening()
      :property:

      get the flatten status of the model

      :return: the flatten status of the model
      :rtype: bool


   .. py:method:: qp()
      :property:

      get the attenuation qp array

      :return: the attenuation qp array
      :rtype: np.ndarray


   .. py:method:: qs()
      :property:

      get the attenuation qs array

      :return: the attenuation qs array
      :rtype: np.ndarray


   .. py:method:: remove_topo()

      make the thickness for the first later to be 0 when the thickness is smaller than 0.


   .. py:method:: rh()
      :property:

      get the density array

      :return: the density array
      :rtype: np.ndarray


   .. py:method:: th()
      :property:

      get the thickness array

      :return: the thickness array
      :rtype: np.ndarray


   .. py:method:: vp()
      :property:

      get the vp array

      :return: the vp array
      :rtype: np.ndarray


   .. py:method:: vs()
      :property:

      get the vs array

      :return: the vs array
      :rtype: np.ndarray



.. py:class:: SourceModel(sdep = 0.0, srcType = 'dc', source_mechanism = None)

   Bases: :py:obj:`object`

   the information about the the source used in the FK

   :param sdep: the depth of the source (km), and it should not be located between the interfaces of the Earth model, defaults to 0
   :type sdep: float
   :param srcType: the source type, can be ep (explosion), sf (single force) or dc (double couple), defaults to "dc"
   :type srcType: str, optional
   :param source_mechanism: a list with length of 1 (ep), 3 (sf), 4 or 7 (dc) with the same order as FK, or a Event of obspy (can read CMT solution file using obspy.read_events), defaults to None
   :type source_mechanism: Optional[Union[list, np.ndarray]], optional
   :raises PyfkError: [description]

   .. py:method:: __repr__()

      Return repr(self).


   .. py:method:: _update_source_mechanism(source_mechanism)

      the internal function to update the source mechanism information

      :param source_mechanism: a list with length of 1 (ep), 3 (sf), 4 or 7 (dc) with the same order as FK, or a Event of obspy (can read CMT solution file using obspy.read_events)
      :type source_mechanism: Optional[Union[list, np.ndarray]]
      :raises PyfkError: source_mechanism should be a 1D array
      :raises PyfkError: length of source_mechanism is not correct
      :raises PyfkError: source_mechanism must be None, a list or numpy.ndarray


   .. py:method:: calculate_radiation_pattern(az)

      calculate the radiation pattern 3*3 array

      :param az: station azimuth in degree measured from the North (clockwise)
      :type az: float
      :raises PyfkError: length of source_mechanism must be 1, 3, 4, 7


   .. py:method:: m0()
      :property:

      get the value associated with the magnitude in FK

      :return: the value associated with the magnitude in FK
      :rtype: float


   .. py:method:: nn()
      :property:

      get the value associated with the source type

      :return: the value associated with the source type
      :rtype: int


   .. py:method:: rad()
      :property:

      get the radiation pattern

      :return: the radiation pattern
      :rtype: np.ndarray


   .. py:method:: sdep()
      :property:

      get the source depth in km

      :return: the source depth in km
      :rtype: float


   .. py:method:: srcType()
      :property:

      get the source type (ep, sf or dc)

      :return: the source type (ep, sf or dc)
      :rtype: str


   .. py:method:: update_source_mechanism(source_mechanism)

      update the source mechanism information after creation of the SourceModel

      :param source_mechanism: a list with length of 1 (ep), 3 (sf), 4 or 7 (dc) with the same order as FK, or a Event of obspy (can read CMT solution file using obspy.read_events)
      :type source_mechanism: Union[list, np.ndarray, Event]
      :raises PyfkError: source mechanism couldn't be None



.. py:function:: calculate_gf(config = None)

   Compute displacements in cm in the up, radial (outward), and transverse (clockwise) directions produced by different seismic sources

   :param config: the configuration of calculating the Green's function, defaults to None
   :type config: Optional[Config], optional
   :return: if npt==2 or 1, return a 2D list, and each row represents the static displacements; otherwise, return a list of Stream, each stream keeps the order of GF as in FK, and the order of streams is the same as the receiver_distance.
   :rtype: Union[List[Stream], List[Stream]]


.. py:function:: calculate_sync(gf, config, az = 0, source_time_function = None)

   Compute displacements in cm in the up, radial (outward), and transverse (clockwise) directions produced by different seismic sources

   :param gf: the Green's function list (or just an obspy Stream representing one distance) from calculate_gf; or read from the Green's function database from FK
   :type gf: Union[List[Stream], Stream]
   :param config: the configuration of sync calculation
   :type config: Config
   :param az: set station azimuth in degree measured from the North, defaults to 0
   :type az: Union[float, int], optional
   :param source_time_function: should be an obspy Trace with the data as the source time function, can use generate_source_time_function to generate a trapezoid shaped source time function, defaults to None
   :type source_time_function: Optional[Trace], optional
   :raises PyfkError: az must be a number
   :raises PyfkError: must provide a source time function
   :raises PyfkError: check input Green's function
   :raises PyfkError: delta for the source time function and the Green's function should be the same
   :return: a list of three components stream (ordered as z, r, t)
   :rtype: List[Stream]


.. py:function:: generate_source_time_function(dura = 0.0, rise = 0.5, delta = 0.1)

   [summary]

   :param dura: [description], defaults to 0.
   :type dura: float, optional
   :param rise: [description], defaults to 0.5
   :type rise: float, optional
   :param delta: [description], defaults to 0.1
   :type delta: float, optional
   :return: [description]
   :rtype: Trace


